#include <stdio.h>
#include <stdlib.h>

void input_size(int *n, int *m, int *err);
void pointer_alloc(int **ptr, int *mat, int rows, int cols);
void input_matrix(int **ptr, int rows, int cols, int *err);
void output(int **mat, int rows, int cols);
void snake_vertical(int **src, int **dst, int rows, int cols);
void snake_horizontal(int **src, int **dst, int rows, int cols);

int main() {
    int rows, cols, err = 0;
    input_size(&rows, &cols, &err);
    
    if (err) {
        printf("n/a");
        return 0;
    }

    int *mat_data = malloc(rows * cols * sizeof(int));
    int **matrix = malloc(rows * sizeof(int*));
    if (!mat_data || !matrix) {
        printf("n/a");
        if (mat_data) free(mat_data);
        if (matrix) free(matrix);
        return 0;
    }
    pointer_alloc(matrix, mat_data, rows, cols);
    
    input_matrix(matrix, rows, cols, &err);
    if (err) {
        printf("n/a");
        free(mat_data);
        free(matrix);
        return 0;
    }

    // Vertical sort
    int *vert_data = malloc(rows * cols * sizeof(int));
    int **vert = malloc(rows * sizeof(int*));
    if (!vert_data || !vert) {
        printf("n/a");
        free(mat_data);
        free(matrix);
        if (vert_data) free(vert_data);
        if (vert) free(vert);
        return 0;
    }
    pointer_alloc(vert, vert_data, rows, cols);
    snake_vertical(matrix, vert, rows, cols);
    output(vert, rows, cols);
    printf("\n\n");

    // Horizontal sort
    int *horiz_data = malloc(rows * cols * sizeof(int));
    int **horiz = malloc(rows * sizeof(int*));
    if (!horiz_data || !horiz) {
        printf("n/a");
        free(mat_data);
        free(matrix);
        free(vert_data);
        free(vert);
        if (horiz_data) free(horiz_data);
        if (horiz) free(horiz);
        return 0;
    }
    pointer_alloc(horiz, horiz_data, rows, cols);
    snake_horizontal(matrix, horiz, rows, cols);
    output(horiz, rows, cols);

    // Cleanup
    free(mat_data);
    free(matrix);
    free(vert_data);
    free(vert);
    free(horiz_data);
    free(horiz);
    return 0;
}

void snake_vertical(int **src, int **dst, int rows, int cols) {
    int *tmp = malloc(rows * cols * sizeof(int));
    if (!tmp) return;
    
    // Flatten and sort
    int k = 0;
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            tmp[k++] = src[i][j];
    
    for (int i = 0; i < rows*cols-1; i++)
        for (int j = 0; j < rows*cols-i-1; j++)
            if (tmp[j] > tmp[j+1]) {
                int t = tmp[j];
                tmp[j] = tmp[j+1];
                tmp[j+1] = t;
            }
    
    // Fill snake
    k = 0;
    for (int j = 0; j < cols; j++) {
        if (j % 2 == 0) {
            for (int i = 0; i < rows; i++)
                dst[i][j] = tmp[k++];
        } else {
            for (int i = rows-1; i >= 0; i--)
                dst[i][j] = tmp[k++];
        }
    }
    free(tmp);
}

void snake_horizontal(int **src, int **dst, int rows, int cols) {
    int *tmp = malloc(rows * cols * sizeof(int));
    if (!tmp) return;
    
    // Flatten and sort
    int k = 0;
    for (int i = 0; i < rows; i++)
        for (int j = 0; j < cols; j++)
            tmp[k++] = src[i][j];
    
    for (int i = 0; i < rows*cols-1; i++)
        for (int j = 0; j < rows*cols-i-1; j++)
            if (tmp[j] > tmp[j+1]) {
                int t = tmp[j];
                tmp[j] = tmp[j+1];
                tmp[j+1] = t;
            }
    
    // Fill snake
    k = 0;
    for (int i = 0; i < rows; i++) {
        if (i % 2 == 0) {
            for (int j = 0; j < cols; j++)
                dst[i][j] = tmp[k++];
        } else {
            for (int j = cols-1; j >= 0; j--)
                dst[i][j] = tmp[k++];
        }
    }
    free(tmp);
}

// Остальные функции (input_size, pointer_alloc, input_matrix, output) 
// остаются аналогичными предыдущему варианту, но с добавлением проверок
